% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NIST_import_routines.R
\name{verify_import_requirements}
\alias{verify_import_requirements}
\title{Verify an import file's properties}
\usage{
verify_import_requirements(
  obj,
  ignore_extra = TRUE,
  requirements_obj = "import_requirements",
  file_name = "import_requirements",
  log_issues_as = "warn",
  log_ns = "db"
)
}
\arguments{
\item{obj}{LIST of the object to import matching structure expectations,
typically from a JSON file fed through [full_import]}

\item{ignore_extra}{LGL scalar of whether to ignore extraneous import
elements or stop the import process (default: TRUE)}

\item{requirements_obj}{CHR scalar of the name of an R object holding import
requirements; this is a convenience shorthand to prevent multiple imports
from parameter `file_name` (default: "import_requirements")}

\item{file_name}{CHR scalar of the name of a file holding import
requirements; if this has already been added to the calling environment,
`requirements_obj` will be used preferentially as the name of that object}

\item{log_issues_as}{CHR scalar of the log level to use (default: "warn"),
which must be a valid log level as in [logger::FATAL]; will be ignored if
the [logger] package isn't available}

\item{log_ns}{CHR scalar of the logging namespace to use (default: "db")}
}
\value{
A tibble object with 9 columns containing the results of the checks.
}
\description{
Checks an import file's characteristics against expectations. This is mostly
a sanity check against changing conditions from project to project. Import
requirements should be defined at the environment level and enumerated as a
JSON object, which can be created by calling [make_requirements] on an
example import for simplicity. An example is provided in the 'examples'
directory as "NIST_import_requirements.json". If multiple requirements are in
use (e.g. pulling from multiple locations), this can be run multiple times
with different values of `requirement_obj` or `file_name`.
}
\details{
The return from this is a tibble with 9 columns. The first is the name of the
import object member, typically the file name. If a single, unnested import
object is provided this will be "import object". The other columns include
the following verification checks:

1. has_all_required: Are all required names present in the sample?
(TRUE/FALSE)

2. missing_requirements: Character vectors naming any of the missing
requirements

3. has_full_detail: Is all expected detail present? (TRUE/FALSE)

4. missing_detail: Character vectors naming any missing value sets

5. has_extra: Are there unexpected values provided? (TRUE/FALSE)

6. extra_cols: Character vectors naming any has_extra columns; these will be
dropped from the import but are provided for information sake

7. has_name_mismatches: Are there name differences between the import
requirement elements and the import object? (TRUE/FALSE)

8. mismatched_names: Named lists enumerating which named elements (if any)
from the import object did not match name expectations in the requirements

All of this is defined by the `requirements_obj` list. Do not provide that
list directly, instead pass this function the name of the requirements object
for interoperability. If a `requirements_obj` cannot be identified via
[base::exists] then the `file_name` will take precedence and be imported.
Initial use and set up may be easier in interactive sessions.
}
\note{
If `file_name` is provided, it need not be fully defined. The value
  provided will be used to search the project directory.
}
