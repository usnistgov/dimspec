% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/db_comm.R
\name{resolve_normalization_value}
\alias{resolve_normalization_value}
\title{Resolve a normalization value against the database}
\usage{
resolve_normalization_value(
  this_value,
  db_table,
  id_column = "id",
  case_sensitive = FALSE,
  fuzzy = FALSE,
  db_conn = con,
  log_ns = "db",
  ...
)
}
\arguments{
\item{this_value}{CHR (or coercible to) scalar value to look up}

\item{db_table}{CHR scalar of the database table to search}

\item{case_sensitive}{LGL scalar of whether to match on a case sensitive
basis (the default TRUE searches for values as-provided) or whether to
coerce value matches by upper, lower, sentence, and title case matches}

\item{fuzzy}{LGL scalar of whether to do a "fuzzy" match in the sense that
values provided are wrapped in an SQL "LIKE '%value%'" clause; overrides
the `case_sensitive` setting if TRUE (default: FALSE).}

\item{db_conn}{connection object (default: con)}

\item{log_ns}{CHR scalar of the logging namespace to use during execution
(default: "db")}

\item{...}{other values to add to the normalization table, where names must
match the table schema}
}
\value{
The database primary key (typically INT) of the normalized value
}
\description{
Normalized SQL databases often need to resolve primary keys. This function
checks for a given value in a given table and either returns the matching
index value or, if a value is not found and `interactive()` is TRUE, it will
add that value to the table and return the new index value. It will look for
the first matching value in all columns of the requested table to support
loose finding of identifiers and is meant to operate only on normalization
tables (i.e. look up tables).
}
\details{
The search itself is done using [check_for_value].
}
\note{
This is mostly a DRY convenience function to avoid having to write the
  loookup and add logic each time.

Interactive sessions are required to add new values
}
