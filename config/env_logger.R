# Logging on/off is set in env_glob.txt ----------------------------------------
require(logger)
require(glue)
# Universal settings -----------------------------------------------------------
# Set the desired directory to store logs.
LOG_DIRECTORY  <- ifelse(exists("LOG_DIRECTORY"), LOG_DIRECTORY, here::here("logs"))
if (!dir.exists(LOG_DIRECTORY)) dir.create(LOG_DIRECTORY)

# Set custom layouts here as needed here for each level or destination.
layout_console <- layout_glue_generator(
  format = paste('[{crayon::italic(format(time, "%Y-%m-%d %H:%M:%OS3"))}]', 
                 "<{crayon::bold(ns)}>",
                 "{crayon::bold(colorize_by_log_level(level, levelr))}",
                 "in fn {fn}(): {grayscale_by_log_level(msg, levelr)}")
)
layout_file <- layout_glue_generator(
  format = paste('[{format(time, "%Y-%m-%d %H:%M:%OS3")}] <{ns}> {level}',
                 "in fn {fn}(): {msg}")
)
log_formatter(formatter_glue)

# Set log_remove_color as a regex string that will remove color formatting from
# the logs to be readable back in a coherent manner. The default will catch MOST
# formatting done by [crayon::italic], [crayon::bold],
# [logger::colorize_by_log_level], and [logger::grayscale_by_log_level].
log_remove_color <- "\\\033|\\[[0-9;]*m"

# This will split log messages into a vector, useful for printing to an R object
# for interactive log inspection. This MUST match exactly the formats defined
# above to prevent errors in [log_as_dataframe] execution.
log_split_column <- " <|> | in fn |\\(\\): "

# Settings for individual logging levels ---------------------------------------
# These settings could eventually live in a database table easily enough, which
# may be the better use, but wanted to abstract this for use in other projects.
# At each level, "log" is whether or not to record the log, "to" is where to put
# output (one of "file", "console", or "both" - note if the logger package is
# not available this will default to console only), "file" defines the location
# of output when "to" is either "file" or "both", and "threshold" controls what
# level of the logger to record (must be one of the valid thresholds in
# logger_levels if using the logger package).
LOGGING <- list(
  GLOBAL = list(log = TRUE,
                ns = "global",
                to = "both",
                file = here::here(LOG_DIRECTORY, "log.txt"),
                threshold = "info"),
  DB     = list(log = TRUE,
                ns = "db",
                to = "both",
                file = here::here(LOG_DIRECTORY, "log_db.txt"),
                threshold = "info"),
  API    = list(log = TRUE,
                ns = "api",
                to = "file",
                file = here::here(LOG_DIRECTORY, "log_api.txt"),
                threshold = "info"),
  RDK    = list(log = TRUE,
                ns = ifelse(exists("PYENV_REF"), PYENV_REF, "rdk"),
                to = "both",
                file = here::here(LOG_DIRECTORY, sprintf("log_%s.txt", ifelse(exists("PYENV_REF"), PYENV_REF, "rdk"))),
                threshold = "info"),
  SHINY  = list(log = TRUE,
                ns = "shiny",
                to = "file",
                file = here::here(LOG_DIRECTORY, "log_shiny.txt"),
                threshold = "info")
)
LOGGING_WARNS  <- TRUE
LOGGING_ERRORS <- TRUE
RENV_ESTABLISHED_LOGGER <- TRUE

# Supporting functions ---------------------------------------------------------

#' Pull a log file into an R object
#'
#' Log messages generated by logger with anything other than the standard
#' formatting options can have multiple formatting tags to display in the R
#' console. These "junk up" any resulting object. If you want to read it
#' directly in the console and preserve formatting, call [read_log] with the
#' default `as_object` argument (FALSE). For deeper inspection, a data frame
#' works well, provided the formatting matches up. In `env_logger.R` there is an
#' option to set formatting layouts. In addition to setting formatting layouts,
#' generate regex strings matching the desired format - `log_remove_color` will
#' remove the colors (the majority should be caught by the string provided as
#' the default in this package) and `log_split_column` will split the lines in
#' your logging file into discrete categories named by `df_titles`.
#'
#' This will attempt to fail gracefully.
#'
#' @note If "time" is included and `condense` == TRUE, the log messages in the
#'   resulting tibble will nested to the nearest second.
#' @note If "status" is included it will be a factor with levels including the
#'   valid statuses from logger (see [logger::log_levels]).
#' @note Use care to develop `regex_split` in order to split the log entries
#'   into the appropriate columns as defined by `df_titles`; extra
#'   values will be merged into the messages column.
#'
#' @param file CHR scalar file path to a log file (default NULL is translated as
#'   "log.txt")
#' @param last_n INT scalar of the last 'n' log entries to read.
#' @param condense LGL scalar of whether to nest the resulting tibble by the
#'   nearest second.
#' @param regex_remove CHR scalar regular expression of characters to REMOVE
#'   from log messages via [stringr::str_remove_all]
#' @param regex_split CHR scalar regular expression of characters used to split
#'   the log entry into columns from log messages via [tidyr::separate]
#' @param df_titles CHR vector of headers for the resulting data frame, passed
#'   as the "into" argument of [tidyr::separate]
#'
#' @return tibble with one row per log entry (or groups)
#' @export
#'
#' @usage log_as_dataframe("log.txt")
log_as_dataframe <- function(file = NULL,
                             last_n = Inf,
                             condense = TRUE,
                             regex_remove = log_remove_color,
                             regex_split = log_split_column,
                             df_titles = c("time", "namespace", "status", "fn", "message")
) {
  sapply(c("stringr", "dplyr", "tidyr", "lubridate"), require, character.only = TRUE)
  log <- read_log(file, as_object = TRUE, last_n = last_n)
  out <- try(log %>% str_remove_all(regex_remove))
  if ("try-error" %in% class(out)) {
    log_it("error", "Could not parse the log with the provided regex_remove. It is being returned as-is.")
    attr(out, "formatted") <- FALSE
    return(log)
  } else {
    log <- out
  }
  out <- try(
    log %>%
      as_tibble() %>%
      separate(
        col = value,
        sep = regex_split,
        into = df_titles,
        fill = "left",
        extra = "merge",
        remove = FALSE
      )
  )
  if ("try-error" %in% class(out)) {
    log_it("error", "Could not separate the log into the requested columns with the provided regex_split. One of regex_remove or regex_split may be a problem, if not all formatting tags are being removed properly or the split regex is incorrect.")
    attr(out, "formatted") <- FALSE
    return(log)
  } else {
    log <- out
  }
  out <- try(
    log %>%
      fill(everything(), .direction = "down") %>%
      mutate(time = if ("time" %in% names(log)) round(as_datetime(time), 0) else NA,
             namespace = if ("namespace" %in% names(log)) as.factor(namespace) else NA,
             status = if ("status" %in% names(log)) {
               factor(status,
                      levels = rev(c("FATAL", "ERROR", "WARN", "SUCCESS", "INFO", "DEBUG", "TRACE")),
                      ordered = TRUE) 
             } else {
               NA
             },
             fn = if ("fn" %in% names(out)) as.factor(fn) else NA)
  )
  if ("try-error" %in% class(out)) {
    log_it("error", "Could not finish wrapping up the formatting. The object will be returned as-is.")
    return(log)
  }
  if (condense && all(c("time", "message") %in% names(log))) {
    out <- out %>%
      group_by(time) %>%
      nest(messages = c(message),
           original = c(value))
  } else {
    out <- out %>%
      relocate(value, .after = everything()) %>%
      rename(original = value)
  }
  attr(out, "formatted") <- TRUE
  return(out)
}

#' Read a log from a log file
#'
#' By default if `file` does not exist (i.e. `file` is not a fully defined path)
#' this looks for log text files in the directory defined by `LOG_DIRECTORY` in
#' the session.
#'
#' @param file CHR scalar file path to a log file (default NULL is translated to
#'   "log.txt")
#' @param last_n INT scalar of the last 'n' log entries to read.
#' @param as_object LGL scalar of whether to return the log as an R object or
#'   just to print the log to the console.
#'
#' @return CHR vector of the requested log file entries if `as_object` is TRUE,
#'   or none with a console print if `as_object` is FALSE
#' @export
#'
#' @usage read_log("log.txt")
read_log <- function(file = NULL, last_n = Inf, as_object = FALSE) {
  if (!file.exists(file)) {
    if (!exists("LOG_DIRECTORY")) stop("Session object LOG_DIRECTORY is not set.")
    if (is.null(file)) {
      file <- here::here(LOG_DIRECTORY, "log.txt")
    } else {
      file <- here::here(LOG_DIRECTORY, file)
    }
  }
  stopifnot(file.exists(file))
  out <- try(readLines(con = file))
  last_n <- abs(last_n)
  if (last_n == Inf || last_n > length(out)) {
    last_n <- length(out)
  }
  keep_lines <- seq.int(from = length(out) - last_n, to = length(out), by = 1)
  out <- out[keep_lines]
  if (as_object) {
    return(out)
  } else {
    cat(out, sep = "\n")
  }
}

#' Update logger settings
#'
#' This applies the internal routing and formatting for logger functions to the
#' current value of the LOGGING object. If LOGGING is changed (i.e. a logging
#' namespace is added or changed) this function should be run to update routing
#' and formatting to be in line with the current settings.
#'
#' @note The calling stack for auto logging of warnings and errors does not work
#' with background processes. These settings call [logger::log_warnings()] and
#' [logger::log_errors()].
#'
#' @note This function is used only for its side effects.
#'
#' @param log_all_warnings LGL scalar indicating whether or not to log all
#'   warnings (default: TRUE)
#' @param log_all_errors LGL scalar indicating whether or not to log all errors
#'   (default: TRUE)
#'
#' @return None
#' @export
#' 
#' @usage update_logger_settings(log_all_warnings = FALSE, log_all_errors =
#'   FALSE)
update_logger_settings <- function(log_all_warnings = TRUE, log_all_errors = TRUE) {
  if (!exists("LOGGING")) stop("Object LOGGING containing logger settings is not available.")
  if (!exists("LOG_DIRECTORY")) LOG_DIRECTORY <- here::here("logs")
  lapply(LOGGING,
         function(x) {
           if (x$log) {
             if (!x$to %in% c("both", "console", "file")) {
               stop(sprintf('Value of %s in env_logger.R must be one of "both", "console", or "file".', x$to))
             }
             if (x$to %in% c("both", "console")) {
               if (!interactive()) x$to <- "file"
             }
             if (x$to %in% c("both", "console")) {
               layout <- layout_console
             } else {
               layout <- layout_file
             }
             if (x$to %in% c("file", "both")) {
               if (!dir.exists(LOG_DIRECTORY)) dir.create(LOG_DIRECTORY)
               if (!file.exists(x$file)) file.create(x$file)
             }
             log_appender(
               switch(x$to,
                      "console" = appender_console,
                      "file"    = appender_file(file = x$file, max_lines = 10000, max_files = 10L),
                      "both"    = appender_tee(file = x$file, max_lines = 10000, max_files = 10L)
               ),
               namespace = x$ns
             )
             log_threshold(level = toupper(x$threshold), namespace = x$ns)
             log_layout(layout = layout, namespace = x$ns)
           }
         }
  )
  if (exists("LOGGING_WARNS") && LOGGING_WARNS && log_all_warnings) {
    if ("warning" %in% names(globalCallingHandlers())) {
      if (!stringr::str_detect(paste0(deparse(globalCallingHandlers()$warning), collapse = ""), "logger::log"))
        log_warnings()
    } else {
      log_warnings()
    }
  }
  if (exists("LOGGING_ERRORS") && LOGGING_ERRORS && log_all_errors) {
    if ("error" %in% names(globalCallingHandlers())) {
      if (!stringr::str_detect(paste0(deparse(globalCallingHandlers()$error), collapse = ""), "logger::log"))
        log_errors()
    } else {
      log_errors()
    }
  }
}
